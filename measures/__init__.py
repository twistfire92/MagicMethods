class Measure:
    measure_sign_mapper = {}
    name: str

    def __init_subclass__(cls, sign=None):
        cls.name = cls.__name__.lower()
        """
            Ниже прошу обратить внимание на то, как мы обновляем словарь с обозначениями.
            Если при описании класса наследника мы не указали sign, подставится name этого класса.
            Так же будет выводиться на печать. Пример - сантиметры.
        """
        cls.measure_sign_mapper.update({cls.name: sign or cls.name})
    """
        На лекции был вопрос почему measure_sign_mapper меняется 
        только у родительского класса Measure, но не меняется у наследников. 
        А name в свою очередь инициализируется у класса наследника.
        Я ответил немного не так. Отвечаю сейчас корректнее простым языком:
        
            Мы вызываем метод update, который обновляет уже существующее значение.
            Чтобы обновить что-то, это что-то надо получить. При получении этого атрибута
            мы ищем его в классе-наследнике, не находим там и идем к родителю, где и находим и обновляем.
            
            С атрибутом name ситуация другая. Мы явно говорим, 
            что этот атрибут у класса наследника надо инициализировать с конкретным значением
    """